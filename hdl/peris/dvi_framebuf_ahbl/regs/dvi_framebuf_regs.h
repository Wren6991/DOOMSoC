/*******************************************************************************
*                          AUTOGENERATED BY REGBLOCK                           *
*                            Do not edit manually.                             *
*          Edit the source file (or regblock utility) and regenerate.          *
*******************************************************************************/

#ifndef _DVI_FRAMEBUF_REGS_H_
#define _DVI_FRAMEBUF_REGS_H_

// Block name           : dvi_framebuf
// Bus type             : apb
// Bus data width       : 32
// Bus address width    : 16

// Controls for displaying a RAM-resident framebuffer, or synchronously-swapped
// set of framebuffers, on a DVI link. The DVI display resolution is fixed, but
// this hardware supports doubling/quadrupling of framebuffer pixels to achieve
// lower resolution and lower video bandwidth than is required for full-
// resolution video.

#define DVI_FRAMEBUF_CSR_OFFS 0
#define DVI_FRAMEBUF_FRAMEBUF_OFFS 4
#define DVI_FRAMEBUF_DISPSIZE_OFFS 8
#define DVI_FRAMEBUF_PALETTE_OFFS 12

/*******************************************************************************
*                                     CSR                                      *
*******************************************************************************/

// Control and status register

// Field: CSR_EN  Access: RW
// If 1, enable both DVI output and pixel DMA. The DMA immediately starts
// filling the pixel FIFO with the first n pixels. The DVI output starts from
// the beginning of the vertical blanking period, ensuring ample time for the
// first pixel fetch. The first VIRQ is generated at the end of the first frame,
// once the DMA has fetched the last pixels.
#define DVI_FRAMEBUF_CSR_EN_LSB  0
#define DVI_FRAMEBUF_CSR_EN_BITS 1
#define DVI_FRAMEBUF_CSR_EN_MASK 0x1
// Field: CSR_VIRQ  Access: W1C
// Vertical interrupt flag. VIRQ is triggered after the pixel DMA fetches the
// last pixels of a frame, which is slightly before those pixels actually appear
// on the DVI link. The VIRQ is acknowledged (cleared) by writing 1 to this
// field.
#define DVI_FRAMEBUF_CSR_VIRQ_LSB  1
#define DVI_FRAMEBUF_CSR_VIRQ_BITS 1
#define DVI_FRAMEBUF_CSR_VIRQ_MASK 0x2
// Field: CSR_VIRQE  Access: RW
// Vertical interrupt enable. External interrupt request is asserted whenever
// VIRQ and VIRQE are both 1.
#define DVI_FRAMEBUF_CSR_VIRQE_LSB  2
#define DVI_FRAMEBUF_CSR_VIRQE_BITS 1
#define DVI_FRAMEBUF_CSR_VIRQE_MASK 0x4
// Field: CSR_VIRQ_PAUSES_DMA  Access: RW
// If 1, pause pixel DMA whenever VIRQ is high, indicating a vertical interrupt
// that has not yet been acknowledged. This allows a vertical IRQ to update the
// FRAMEBUF pointer synchronously.
#define DVI_FRAMEBUF_CSR_VIRQ_PAUSES_DMA_LSB  3
#define DVI_FRAMEBUF_CSR_VIRQ_PAUSES_DMA_BITS 1
#define DVI_FRAMEBUF_CSR_VIRQ_PAUSES_DMA_MASK 0x8
// Field: CSR_UNDERFLOW  Access: W1C
// Pixel FIFO underflow occurred. There is nothing you can do about it, just
// turn the display off and on again.
#define DVI_FRAMEBUF_CSR_UNDERFLOW_LSB  8
#define DVI_FRAMEBUF_CSR_UNDERFLOW_BITS 1
#define DVI_FRAMEBUF_CSR_UNDERFLOW_MASK 0x100
// Field: CSR_LOG_PIX_REPEAT  Access: RW
// Repeat each pixel 1 << n times horizontally and vertically. This reduces
// display bandwidth by a factor of 1 << n; horizontal repeat occurs inside the
// video hardware, and vertical repeat is achieved by re-fetching the same
// scanline multiple times.
#define DVI_FRAMEBUF_CSR_LOG_PIX_REPEAT_LSB  16
#define DVI_FRAMEBUF_CSR_LOG_PIX_REPEAT_BITS 2
#define DVI_FRAMEBUF_CSR_LOG_PIX_REPEAT_MASK 0x30000

/*******************************************************************************
*                                   FRAMEBUF                                   *
*******************************************************************************/

// Framebuffer pointer. Must be aligned to the size of one SDRAM burst (on
// DOOMSoC ULX3S this is 16 bytes, 8x16b), and the contents is always 8bpp
// paletted. FRAMEBUF can only be safely modified when the video hardware is
// disabled (!CSR_EN), or when the pixel DMA is paused during vertical blanking
// (CSR_VIRQ && CSR_VIRQ_PAUSES_DMA)

// Field: FRAMEBUF  Access: RW
#define DVI_FRAMEBUF_FRAMEBUF_LSB  4
#define DVI_FRAMEBUF_FRAMEBUF_BITS 28
#define DVI_FRAMEBUF_FRAMEBUF_MASK 0xfffffff0

/*******************************************************************************
*                                   DISPSIZE                                   *
*******************************************************************************/

// Read-only display width/height register. Get the maximum display resolution,
// which is achieved when CSR_LOG_PIX_REPEAT is 0

// Field: DISPSIZE_W  Access: ROV
#define DVI_FRAMEBUF_DISPSIZE_W_LSB  0
#define DVI_FRAMEBUF_DISPSIZE_W_BITS 16
#define DVI_FRAMEBUF_DISPSIZE_W_MASK 0xffff
// Field: DISPSIZE_H  Access: ROV
#define DVI_FRAMEBUF_DISPSIZE_H_LSB  16
#define DVI_FRAMEBUF_DISPSIZE_H_BITS 16
#define DVI_FRAMEBUF_DISPSIZE_H_MASK 0xffff0000

/*******************************************************************************
*                                   PALETTE                                    *
*******************************************************************************/

// Write-only palette update. The palette contains 256 entries of RGB888 (R in
// MSB position). Each 32-bit write to this address contains the 8-bit palette
// address to be updated, and the 24-bit pixel colour to be written. No readback
// is provided (the palette RAM read port is in a different clock domain!), so
// for palette read-modify-write operations, software must maintain a shadow
// palette in RAM.

// Field: PALETTE_COLOUR  Access: WF
#define DVI_FRAMEBUF_PALETTE_COLOUR_LSB  0
#define DVI_FRAMEBUF_PALETTE_COLOUR_BITS 24
#define DVI_FRAMEBUF_PALETTE_COLOUR_MASK 0xffffff
// Field: PALETTE_ADDR  Access: WF
#define DVI_FRAMEBUF_PALETTE_ADDR_LSB  24
#define DVI_FRAMEBUF_PALETTE_ADDR_BITS 8
#define DVI_FRAMEBUF_PALETTE_ADDR_MASK 0xff000000

#endif // _DVI_FRAMEBUF_REGS_H_
